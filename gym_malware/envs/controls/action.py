import array
import json
import os
import random
import struct
import subprocess
import sys
import tempfile
from os import listdir
from os.path import isfile, join
import lief  # pip install https://github.com/lief-project/LIEF/releases/download/0.7.0/linux_lief-0.7.0_py3.6.tar.gz

from gym_malware.envs.utils import interface

module_path = os.path.split(os.path.abspath(sys.modules[__name__].__file__))[0]

COMMON_SECTION_NAMES = open(os.path.join(
    module_path, 'section_names.txt'), 'r').read().rstrip().split('\n')
COMMON_IMPORTS = json.load(
    open(os.path.join(module_path, 'small_dll_imports.json'), 'r'))

######################
# explicitly list so that these may be used externally

ACTION_TABLE = {
    "modify_machine_type": "modify_machine_type",
    "pad_overlay": "pad_overlay",
    "append_benign_data_overlay": "append_benign_data_overlay",
    "append_benign_binary_overlay": "append_benign_binary_overlay",
    # "add_bytes_to_section_cave": "add_bytes_to_section_cave",
    "add_section_strings": "add_section_strings",
    "add_section_benign_data": "add_section_benign_data",
    "add_strings_to_overlay": "add_strings_to_overlay",
    "add_imports": "add_imports",
    "rename_section": "rename_section",
    "remove_debug": "remove_debug",
    "modify_optional_header": "modify_optional_header",
    "modify_timestamp": "modify_timestamp",
    "break_optional_header_checksum": "break_optional_header_checksum",
    "upx_unpack": "upx_unpack",
    "upx_pack": "upx_pack",
}


class MalwareManipulator():
    def __init__(self, bytez):
        self.bytez = bytez
        self.trusted_path = module_path + "/trusted/"
        self.good_str_path = module_path + "/good_strings/"
        self.sig_path = module_path + "/signatures/"

    def _randomly_select_trusted_file(self):
        return random.choice(
            [
                join(self.trusted_path, f)
                for f in listdir(self.trusted_path)
                if (f != ".gitkeep") and (isfile(join(self.trusted_path, f)))
            ],
        )

    def _randomly_select_good_strings(self):
        good_strings = random.choice(
            [
                join(self.good_str_path, f)
                for f in listdir(self.good_str_path)
                if (f != ".gitkeep") and (isfile(join(self.good_str_path, f)))
            ],
        )

        with open(good_strings) as f:
            strings = f.read()

        return strings

    def _randomly_select_signatures(self):
        sigs = random.choice(
            [
                join(self.sig_path, f)
                for f in listdir(self.sig_path)
                if (f != ".gitkeep") and (isfile(join(self.sig_path, f)))
            ],
        )

        with open(sigs) as f:
            sig = f.read()

        return sig

    def _random_length(self):
        return 2 ** random.randint(5, 8)

    def _search_cave(
            self,
            name,
            body,
            file_offset,
            vaddr,
            cave_size=128,
            _bytes=b"\x00",
    ):
        found_caves = []
        null_count = 0
        size = len(body)

        for offset in range(size):
            byte = body[offset]
            check = False

            if byte in _bytes:
                null_count += 1
            else:
                check = True

            if offset == size - 1:
                check = True
                offset += 1

            if check:
                if null_count >= cave_size:
                    cave_start = file_offset + offset - null_count
                    cave_end = file_offset + offset
                    cave_size = null_count
                    found_caves.append([cave_start, cave_end, cave_size])
                null_count = 0
        return found_caves

    def _binary_to_bytez(self, binary, imports=False):
        # Write modified binary to disk
        builder = lief.PE.Builder(binary)
        builder.build_imports(imports)
        builder.build()

        self.bytez = array.array("B", builder.get_build()).tobytes()
        return self.bytez

    def _get_info(self):
        flItms = {}
        binary = io.BytesIO(self.bytez)
        binary.seek(int('3C', 16))
        flItms['buffer'] = 0
        flItms['JMPtoCodeAddress'] = 0
        flItms['dis_frm_pehdrs_sectble'] = 248
        flItms['pe_header_location'] = struct.unpack('<i', binary.read(4))[0]
        # Start of COFF
        flItms['COFF_Start'] = flItms['pe_header_location'] + 4
        binary.seek(flItms['COFF_Start'])
        flItms['MachineType'] = struct.unpack('<H', binary.read(2))[0]
        binary.seek(flItms['COFF_Start'] + 2, 0)
        flItms['NumberOfSections'] = struct.unpack('<H', binary.read(2))[0]
        flItms['TimeDateStamp'] = struct.unpack('<I', binary.read(4))[0]
        binary.seek(flItms['COFF_Start'] + 16, 0)
        flItms['SizeOfOptionalHeader'] = struct.unpack('<H', binary.read(2))[0]
        flItms['Characteristics'] = struct.unpack('<H', binary.read(2))[0]
        # End of COFF
        flItms['OptionalHeader_start'] = flItms['COFF_Start'] + 20

        # if flItms['SizeOfOptionalHeader']:
        # Begin Standard Fields section of Optional Header
        binary.seek(flItms['OptionalHeader_start'])
        flItms['Magic'] = struct.unpack('<H', binary.read(2))[0]
        flItms['MajorLinkerVersion'] = struct.unpack("!B", binary.read(1))[0]
        flItms['MinorLinkerVersion'] = struct.unpack("!B", binary.read(1))[0]
        flItms['SizeOfCode'] = struct.unpack("<I", binary.read(4))[0]
        flItms['SizeOfInitializedData'] = struct.unpack("<I", binary.read(4))[0]
        flItms['SizeOfUninitializedData'] = struct.unpack("<I",
                                                          binary.read(4))[0]
        flItms['AddressOfEntryPoint'] = struct.unpack('<I', binary.read(4))[0]
        flItms['PatchLocation'] = flItms['AddressOfEntryPoint']
        flItms['BaseOfCode'] = struct.unpack('<I', binary.read(4))[0]
        if flItms['Magic'] != 0x20B:
            flItms['BaseOfData'] = struct.unpack('<I', binary.read(4))[0]
        # End Standard Fields section of Optional Header
        # Begin Windows-Specific Fields of Optional Header
        if flItms['Magic'] == 0x20B:
            flItms['ImageBase'] = struct.unpack('<Q', binary.read(8))[0]
        else:
            flItms['ImageBase'] = struct.unpack('<I', binary.read(4))[0]
        flItms['SectionAlignment'] = struct.unpack('<I', binary.read(4))[0]
        flItms['FileAlignment'] = struct.unpack('<I', binary.read(4))[0]
        flItms['MajorOperatingSystemVersion'] = struct.unpack('<H',
                                                              binary.read(2))[0]
        flItms['MinorOperatingSystemVersion'] = struct.unpack('<H',
                                                              binary.read(2))[0]
        flItms['MajorImageVersion'] = struct.unpack('<H', binary.read(2))[0]
        flItms['MinorImageVersion'] = struct.unpack('<H', binary.read(2))[0]
        flItms['MajorSubsystemVersion'] = struct.unpack('<H', binary.read(2))[0]
        flItms['MinorSubsystemVersion'] = struct.unpack('<H', binary.read(2))[0]
        flItms['Win32VersionValue'] = struct.unpack('<I', binary.read(4))[0]
        flItms['SizeOfImageLoc'] = binary.tell()
        flItms['SizeOfImage'] = struct.unpack('<I', binary.read(4))[0]
        flItms['SizeOfHeaders'] = struct.unpack('<I', binary.read(4))[0]
        flItms['CheckSum'] = struct.unpack('<I', binary.read(4))[0]
        flItms['Subsystem'] = struct.unpack('<H', binary.read(2))[0]
        flItms['DllCharacteristics'] = struct.unpack('<H', binary.read(2))[0]
        if flItms['Magic'] == 0x20B:
            flItms['SizeOfStackReserve'] = struct.unpack('<Q', binary.read(8))[0]
            flItms['SizeOfStackCommit'] = struct.unpack('<Q', binary.read(8))[0]
            flItms['SizeOfHeapReserve'] = struct.unpack('<Q', binary.read(8))[0]
            flItms['SizeOfHeapCommit'] = struct.unpack('<Q', binary.read(8))[0]

        else:
            flItms['SizeOfStackReserve'] = struct.unpack('<I', binary.read(4))[0]
            flItms['SizeOfStackCommit'] = struct.unpack('<I', binary.read(4))[0]
            flItms['SizeOfHeapReserve'] = struct.unpack('<I', binary.read(4))[0]
            flItms['SizeOfHeapCommit'] = struct.unpack('<I', binary.read(4))[0]
        flItms['LoaderFlags'] = struct.unpack('<I', binary.read(4))[0]  # zero
        flItms['NumberofRvaAndSizes'] = struct.unpack('<I', binary.read(4))[0]
        # End Windows-Specific Fields of Optional Header
        # Begin Data Directories of Optional Header
        flItms['ExportTableRVA'] = struct.unpack('<I', binary.read(4))[0]
        flItms['ExportTableSize'] = struct.unpack('<I', binary.read(4))[0]
        flItms['ImportTableLOCInPEOptHdrs'] = binary.tell()
        # ImportTable SIZE|LOC
        flItms['ImportTableRVA'] = struct.unpack('<I', binary.read(4))[0]
        flItms['ImportTableSize'] = struct.unpack('<I', binary.read(4))[0]
        flItms['ResourceTable'] = struct.unpack('<Q', binary.read(8))[0]
        flItms['ExceptionTable'] = struct.unpack('<Q', binary.read(8))[0]
        flItms['CertTableLOC'] = binary.tell()
        flItms['CertLOC'] = struct.unpack("<I", binary.read(4))[0]
        flItms['CertSize'] = struct.unpack("<I", binary.read(4))[0]
        binary.close()
        return flItms

    def rename_section(self):
        binary = lief.PE.parse(list(self.bytez))
        targeted_section = random.choice(binary.sections)
        targeted_section.name = random.choice(COMMON_SECTION_NAMES)[:5]

        self.bytez = self._binary_to_bytez(binary)
        return self.bytez

    def signature_modify(self):
        sign = self._randomly_select_signatures()
        flItms = self._get_info()
        if flItms['CertLOC'] == 0 or flItms['CertSize'] == 0:
            # append the selected sig
            sign_path = os.path.join(module_path, 'sig', sign)
            with open(sign_path, 'rb') as n:
                cert = n.read()
            f = io.BytesIO(self.bytez)
            f.seek(0)
            f.seek(flItms['CertTableLOC'], 0)
            f.write(struct.pack("<I", len(self.bytez)))
            f.write(struct.pack("<I", len(cert)))
            f.seek(0, io.SEEK_END)
            f.write(cert)
            f.seek(0)
            self.bytez = f.read()
        else:
            # Remove the sig and append the new one
            self.bytez = self.bytez[:flItms['CertLOC']] + self.bytez[flItms['CertLOC'] + flItms['CertSize']:]
            binary = io.BytesIO(self.bytez)
            binary.seek(flItms['CertTableLOC'], 0)
            binary.write(b"\x00\x00\x00\x00\x00\x00\x00\x00")
            binary.seek(0)
            self.bytez = binary.read()
            sign_path = os.path.join(module_path, 'sig', sign)
            with open(sign_path, 'rb') as n:
                cert = n.read()
            f = io.BytesIO(self.bytez)
            f.seek(0)
            f.seek(flItms['CertTableLOC'], 0)
            f.write(struct.pack("<I", len(self.bytez)))
            f.write(struct.pack("<I", len(cert)))
            f.seek(0, io.SEEK_END)
            f.write(cert)
            f.seek(0)
            self.bytez = f.read()
        return self.bytez

    def add_bytes_to_section_cave(self):
        caves = []
        binary = lief.PE.parse(list(self.bytez))
        base_addr = binary.optional_header.imagebase
        for section in binary.sections:
            section_offset = section.pointerto_raw_data
            vaddr = section.virtual_address + base_addr
            body = section.content

            if section.sizeof_raw_data > section.virtual_size:
                body.extend(
                    list(b"\x00" * (section.sizeof_raw_data - section.virtual_size)),
                )

            caves.extend(
                self._search_cave(
                    section.name,
                    body,
                    section_offset,
                    vaddr,
                ),
            )

        if caves:
            random_selected_cave = random.choice(caves)
            upper = random.randrange(256)
            add_bytes = bytearray(
                random.randint(0, upper) for _ in range(random_selected_cave[-1])
            )
            self.bytez = (
                    self.bytez[: random_selected_cave[0]]
                    + add_bytes
                    + self.bytez[random_selected_cave[1]:]
            )

        return self.bytez

    def modify_machine_type(self):
        binary = lief.PE.parse(list(self.bytez))
        binary.header.machine = random.choice(
            [
                lief.PE.MACHINE_TYPES.AMD64,
                lief.PE.MACHINE_TYPES.IA64,
                lief.PE.MACHINE_TYPES.ARM64,
                lief.PE.MACHINE_TYPES.POWERPC,
            ],
        )

        self.bytez = self._binary_to_bytez(binary)

        return self.bytez

    def modify_timestamp(self):
        binary = lief.PE.parse(list(self.bytez))
        binary.header.time_date_stamps = random.choice(
            [
                0,
                868967292,
                993636360,
                587902357,
                872078556,
            ],
        )

        self.bytez = self._binary_to_bytez(binary)

        return self.bytez

    def pad_overlay(self):
        byte_pattern = random.choice([i for i in range(256)])
        overlay = bytearray([byte_pattern] * 100000)
        self.bytez += overlay

        return self.bytez

    def append_benign_data_overlay(self):
        random_benign_file = self._randomly_select_trusted_file()
        benign_binary = lief.PE.parse(random_benign_file)
        benign_binary_section_content = benign_binary.get_section(
            ".text",
        ).content
        overlay = bytearray(benign_binary_section_content)
        self.bytez += overlay

        return self.bytez

    def append_benign_binary_overlay(self):
        random_benign_file = self._randomly_select_trusted_file()

        with open(random_benign_file, "rb") as f:
            benign_binary = f.read()
        self.bytez += benign_binary

        return self.bytez

    def add_section_benign_data(self):
        random_benign_file = self._randomly_select_trusted_file()
        benign_binary = lief.PE.parse(random_benign_file)
        benign_binary_section_content = benign_binary.get_section(
            ".text",
        ).content

        binary = lief.PE.parse(list(self.bytez))

        current_section_names = [section.name for section in binary.sections]
        available_section_names = list(
            set(COMMON_SECTION_NAMES) - set(current_section_names),
        )
        section = lief.PE.Section(random.choice(available_section_names))
        section.content = benign_binary_section_content
        binary.add_section(section, lief.PE.SECTION_TYPES.DATA)

        self.bytez = self._binary_to_bytez(binary)
        return self.bytez

    def add_section_strings(self):
        good_strings = self._randomly_select_good_strings()
        binary = lief.PE.parse(list(self.bytez))

        current_section_names = [section.name for section in binary.sections]
        available_section_names = list(
            set(COMMON_SECTION_NAMES) - set(current_section_names),
        )
        section = lief.PE.Section(random.choice(available_section_names))
        section.content = [ord(c) for c in good_strings]
        binary.add_section(section, lief.PE.SECTION_TYPES.DATA)

        self.bytez = self._binary_to_bytez(binary)
        return self.bytez

    def add_strings_to_overlay(self):
        """
        Open a txt file of strings from low scoring binaries.
        https://skylightcyber.com/2019/07/18/cylance-i-kill-you/
        """
        good_strings = self._randomly_select_good_strings()
        self.bytez += bytes(good_strings, encoding="ascii")

        return self.bytez

    def add_imports(self):
        binary = lief.PE.parse(list(self.bytez))

        # draw a library at random
        libname = random.choice(list(COMMON_IMPORTS.keys()))
        funcname = random.choice(list(COMMON_IMPORTS[libname]))
        lowerlibname = libname.lower()

        # find this lib in the imports, if it exists
        lib = None
        for im in binary.imports:
            if im.name.lower() == lowerlibname:
                lib = im
                break

        if lib is None:
            # add a new library
            lib = binary.add_library(libname)

        # get current names
        names = {e.name for e in lib.entries}
        if funcname not in names:
            lib.add_entry(funcname)

        self.bytez = self._binary_to_bytez(binary, imports=True)

        return self.bytez

    def remove_debug(self):
        binary = lief.PE.parse(list(self.bytez))

        if binary.has_debug:
            for i, e in enumerate(binary.data_directories):
                if e.type == lief.PE.DATA_DIRECTORY.DEBUG:
                    e.rva = 0
                    e.size = 0
                    self.bytez = self._binary_to_bytez(binary)
                    return self.bytez
        # no debug found
        return self.bytez

    def modify_optional_header(self):
        binary = lief.PE.parse(list(self.bytez))

        oh = {
            "major_linker_version": [2, 6, 7, 9, 11, 14],
            "minor_linker_version": [0, 16, 20, 22, 25],
            "major_operating_system_version": [4, 5, 6, 10],
            "minor_operating_system_version": [0, 1, 3],
            "major_image_version": [0, 1, 5, 6, 10],
            "minor_image_version": [0, 1, 3],
        }

        key = random.choice(list(oh.keys()))

        modified_val = random.choice(oh[key])
        binary.optional_header.__setattr__(key, modified_val)

        self.bytez = self._binary_to_bytez(binary)
        return self.bytez

    def break_optional_header_checksum(self):
        binary = lief.PE.parse(list(self.bytez))
        binary.optional_header.checksum = 0
        self.bytez = self._binary_to_bytez(binary)
        return self.bytez

    def upx_unpack(self):
        # dump bytez to a temporary file
        tmpfilename = os.path.join(
            tempfile._get_default_tempdir(),
            next(tempfile._get_candidate_names()),
        )

        with open(tmpfilename, "wb") as outfile:
            outfile.write(self.bytez)

        with open(os.devnull, "w") as DEVNULL:
            retcode = subprocess.call(
                ["upx", tmpfilename, "-d", "-o", tmpfilename + "_unpacked"],
                stdout=DEVNULL,
                stderr=DEVNULL,
            )

        os.unlink(tmpfilename)

        if retcode == 0:  # sucessfully unpacked
            with open(tmpfilename + "_unpacked", "rb") as result:
                self.bytez = result.read()

            os.unlink(tmpfilename + "_unpacked")

        return self.bytez

    def upx_pack(self):
        # tested with UPX 3.94
        # WARNING: upx compression only works on binaries over 100KB
        tmpfilename = os.path.join(
            tempfile._get_default_tempdir(),
            next(tempfile._get_candidate_names()),
        )

        # dump bytez to a temporary file
        with open(tmpfilename, "wb") as outfile:
            outfile.write(self.bytez)

        options = ["--force", "--overlay=copy"]
        compression_level = random.randint(1, 9)
        options += [f"-{compression_level}"]
        options += [f"--compress-exports={random.randint(0, 1)}"]
        options += [f"--compress-icons={random.randint(0, 3)}"]
        options += [f"--compress-resources={random.randint(0, 1)}"]
        options += [f"--strip-relocs={random.randint(0, 1)}"]

        with open(os.devnull, "w") as DEVNULL:
            retcode = subprocess.call(
                ["upx"] + options + [tmpfilename, "-o", tmpfilename + "_packed"],
                stdout=DEVNULL,
                stderr=DEVNULL,
            )

        os.unlink(tmpfilename)

        if retcode == 0:  # successfully packed

            with open(tmpfilename + "_packed", "rb") as infile:
                self.bytez = infile.read()

            os.unlink(tmpfilename + "_packed")

        return self.bytez


def modify_without_breaking(bytez, action):
    bytez = MalwareManipulator(bytez).__getattribute__(action)()
    return bytez
#
# ACTION_TABLE = {
#     'ARBE': 'ARBE',
#     'imports_append': 'imports_append',
#     'random_imports_append': 'random_imports_append',
#     'ARS': 'ARS',
#     'imports_append2': 'imports_append2',
#     'section_rename': 'section_rename',
#     'section_append': 'section_append',
#     'create_new_entry': 'create_new_entry'
# }
#
#
# # action 操作类
# class MalwareManipulator():
#     def __init__(self, bytez):
#         self.bytez = bytez
#         self.min_append_log2 = 5
#         self.max_append_log2 = 8
#
#     # 构造随机长度
#     def __random_length(self):
#         return 2 ** random.randint(self.min_append_log2, self.max_append_log2)
#
#     # 判断是否已包含某库
#     def __has_random_lib(self, imports, lowerlibname):
#         for im in imports:
#             if im.name.lower() == lowerlibname:
#                 return True
#         return False
#
#     # 把lief结果build成bytez
#     def __binary_to_bytez(self, binary, dos_stub=False, imports=False, overlay=False, relocations=False,
#                           resources=False, tls=False):
#         # write the file back as bytez
#         builder = lief.PE.Builder(binary)
#         builder.build_dos_stub(dos_stub)  # rebuild DOS stub
#
#         builder.build_imports(imports)  # rebuild IAT in another section
#         builder.patch_imports(imports)  # patch original import table with trampolines to new import table
#
#         builder.build_overlay(overlay)  # rebuild overlay
#         builder.build_relocations(relocations)  # rebuild relocation table in another section
#         builder.build_resources(resources)  # rebuild resources in another section
#         builder.build_tls(tls)  # rebuilt TLS object in another section
#
#         builder.build()  # perform the build process
#
#         # return bytestring
#         return array.array('B', builder.get_build()).tobytes()
#
#     # 生成随机的import name
#     def __generate_random_import_libname(self, minlength=5, maxlength=7):
#         length = random.randint(minlength, maxlength)
#         suffix = random.choice(['.dll', '.exe'])
#         return "".join(chr(random.randrange(ord('.'), ord('z'))) for _ in range(length)) + suffix
#
#     # 生成随机函数名
#     def __generate_random_name(self, minlength=5, maxlength=7):
#         length = random.randint(minlength, maxlength)
#         return "".join(chr(random.randrange(ord('.'), ord('z'))) for _ in range(length))
#
#     # action 1: append bytes to the overlay (end of PE file)
#     def ARBE(self, seed=None):  # random加的？？？
#         random.seed(seed)
#         L = self.__random_length()
#         # choose the upper bound for a uniform distribution in [0,upper]
#         upper = random.randrange(256)
#         # upper chooses the upper bound on uniform distribution:
#         # upper=0 would append with all 0s
#         # upper=126 would append with "printable ascii"
#         # upper=255 would append with any character
#         return self.bytez + bytes([random.randint(0, upper) for _ in range(L)])
#
#     # action 2: add a function to the import address table that is never used
#     def imports_append(self, seed=None):
#         # add (unused) imports
#         random.seed(seed)
#         binary = lief.parse(self.bytez)
#
#         importslist = binary.imports
#         # draw a library at random
#         libname = random.choice(list(COMMON_IMPORTS.keys()))
#         funcname = random.choice(list(COMMON_IMPORTS[libname]))
#         lowerlibname = libname.lower()
#
#         count_limit = 0
#
#         while self.__has_random_lib(importslist, lowerlibname):
#             # draw a library at random
#             libname = random.choice(list(COMMON_IMPORTS.keys()))
#             funcname = random.choice(list(COMMON_IMPORTS[libname]))
#             lowerlibname = libname.lower()
#             count_limit += 1
#             if count_limit > 10:
#                 break
#
#         # add a new library
#         lib = binary.add_library(libname)
#
#         # get current names
#         names = set([e.name for e in lib.entries])
#         if not funcname in names:
#             lib.add_entry(funcname)
#
#         self.bytez = self.__binary_to_bytez(binary, imports=True)
#
#         return self.bytez
#
#     # action 3: add a function to the import address table that is random name
#     def random_imports_append(self, seed=None):
#         # add (unused) imports
#         random.seed(seed)
#         binary = lief.parse(self.bytez)
#         # draw a library at random
#         libname = self.__generate_random_import_libname()
#         funcname = self.__generate_random_name()
#         lowerlibname = libname.lower()
#         # append this lib in the imports
#         lib = binary.add_library(lowerlibname)
#         lib.add_entry(funcname)
#
#         self.bytez = self.__binary_to_bytez(binary, imports=True)
#
#         return self.bytez
#
#     # action 4: create a new(unused) sections
#     def ARS(self, seed=None):
#         random.seed(seed)
#         binary = lief.parse(self.bytez)
#         # 建立一个section
#         new_section = lief.PE.Section(self.__generate_random_name())
#
#         # fill with random content
#         upper = random.randrange(256)  # section含content、虚拟地址、type
#         L = self.__random_length()
#         new_section.content = [random.randint(0, upper) for _ in range(L)]
#
#         new_section.virtual_address = max(
#             [s.virtual_address + s.size for s in binary.sections])
#
#         # add a new empty section
#         binary.add_section(new_section,
#                            random.choice([
#                                lief.PE.SECTION_TYPES.BSS,
#                                lief.PE.SECTION_TYPES.DATA,
#                                lief.PE.SECTION_TYPES.EXPORT,
#                                lief.PE.SECTION_TYPES.IDATA,
#                                lief.PE.SECTION_TYPES.RELOCATION,
#                                lief.PE.SECTION_TYPES.RESOURCE,
#                                lief.PE.SECTION_TYPES.TEXT,
#                                lief.PE.SECTION_TYPES.TLS_,
#                                lief.PE.SECTION_TYPES.UNKNOWN,
#                            ]))
#
#         self.bytez = self.__binary_to_bytez(binary)
#         return self.bytez
#
#     # action 5: add a function to the import address table that is never used
#     def imports_append2(self, seed=None):
#         # add (unused) imports
#         random.seed(seed)
#         binary = lief.parse(self.bytez)
#         # draw a library at random
#         libname = random.choice(list(COMMON_IMPORTS.keys()))  # 随机选择？
#         funcname = random.choice(list(COMMON_IMPORTS[libname]))  # 随机选择？
#         lowerlibname = libname.lower()
#         # find this lib in the imports, if it exists
#         lib = None
#         for im in binary.imports:
#             if im.name.lower() == lowerlibname:
#                 lib = im
#                 break
#         if lib is None:
#             # add a new library
#             lib = binary.add_library(libname)
#         # get current names
#         names = set([e.name for e in lib.entries])  # 一个lib + lib里的entry
#         if not funcname in names:
#             lib.add_entry(funcname)
#
#         self.bytez = self.__binary_to_bytez(binary, imports=True)
#
#         return self.bytez
#
#     # action 6: manipulate existing section names
#     def section_rename(self, seed=None):
#         # rename a random section
#         random.seed(seed)
#         binary = lief.parse(self.bytez)
#         targeted_section = random.choice(binary.sections)
#         targeted_section.name = random.choice(COMMON_SECTION_NAMES)[:7]  # current version of lief not allowing 8 chars?
#
#         self.bytez = self.__binary_to_bytez(binary)
#
#         return self.bytez
#
#     # TODO: lief接口问题
#     # action 7: append bytes to extra space at the end of sections
#     def section_append(self, seed=None):
#         # append to a section (changes size and entropy)
#         random.seed(seed)
#         binary = lief.parse(self.bytez)
#         targeted_section = random.choice(binary.sections)
#         L = self.__random_length()
#         print("targeted_section.size:",targeted_section.size)
#         print("targeted_section.content:",type(targeted_section.content))
#         available_size = targeted_section.size - len(targeted_section.content)
#         print("available_size:{}".format(available_size))
#         if L > available_size:
#             L = available_size
#
#         upper = random.randrange(256)
#         # targeted_section.content = targeted_section.content + \
#         #                            [random.randint(0, upper) for _ in range(L)]
#         for i in range(L):
#             targeted_section.content[L+i] = os.urandom(1)
#         self.bytez = self.__binary_to_bytez(binary)
#         return self.bytez
#
#     # action 8: create a new entry point which immediately jumps to the original entry point
#     def create_new_entry(self, seed=None):
#         # create a new section with jump to old entry point, and change entry point
#         # DRAFT: this may have a few technical issues with it (not accounting for relocations),
#         # but is a proof of concept for functionality
#         random.seed(seed)
#
#         binary = lief.parse(self.bytez)
#
#         # get entry point
#         entry_point = binary.optional_header.addressof_entrypoint
#
#         # get name of section
#         entryname = binary.section_from_rva(entry_point).name
#
#         # create a new section
#         new_section = lief.PE.Section(entryname + "".join(chr(random.randrange(
#             ord('.'), ord('z'))) for _ in range(3)))  # e.g., ".text" + 3 random characters
#         # push [old_entry_point]; ret
#         new_section.content = [
#                                   0x68] + list(struct.pack("<I", entry_point + 0x10000)) + [0xc3]
#         new_section.virtual_address = max(
#             [s.virtual_address + s.size for s in binary.sections])
#         # TO DO: account for base relocation (this is just a proof of concepts)
#
#         # add new section
#         binary.add_section(new_section, lief.PE.SECTION_TYPES.TEXT)
#
#         # redirect entry point
#         binary.optional_header.addressof_entrypoint = new_section.virtual_address
#
#         self.bytez = self.__binary_to_bytez(binary)
#         return self.bytez
#
#
# def modify_without_breaking(bytez, action=None, seed=None):
#     _action = MalwareManipulator(bytez).__getattribute__(ACTION_TABLE[action])
#
#     try:
#         bytez = _action(seed)
#     except Exception as e:  # ..then become petulant
#         print(e)
#         print('action error ')
#
#     import hashlib
#     m = hashlib.sha256()
#     m.update(bytez)
#     return bytez
#
#
# def test_ARBE(bytez):
#     binary = lief.parse(bytez)
#     manip = MalwareManipulator(bytez)
#     bytez2 = manip.ARBE()
#     binary2 = lief.parse(bytez2)
#     if len(binary.overlay) == len(binary2.overlay):
#         return 0
#     else:
#         return 1
#
#
# def test_imports_append(bytez):
#     binary = lief.parse(bytez)
#     # SUCCEEDS, but note that lief builder also adds a new ".l1" section for each patch of the imports
#     manip = MalwareManipulator(bytez)
#     bytez2 = manip.imports_append(bytez)
#     # bytez2 = manip.imports_append_org(bytez)
#     binary2 = lief.parse(bytez2)
#     # set1 = set(binary.imported_functions)
#     # set2 = set(binary2.imported_functions)
#     # diff = set2.difference(set1)
#     # print(list(diff))
#     if len(binary.imported_functions) == len(binary2.imported_functions):
#         return 0
#     else:
#         return 1
#
#
# def test_random_imports_append(bytez):
#     binary = lief.parse(bytez)
#     manip = MalwareManipulator(bytez)
#     bytez2 = manip.imports_append(bytez)
#     binary2 = lief.parse(bytez2)
#     if len(binary.imported_functions) == len(binary2.imported_functions):
#         return 0
#     else:
#         return 1
#
#
# def test_ARS(bytez):
#     binary = lief.parse(bytez)
#     manip = MalwareManipulator(bytez)
#     bytez2 = manip.ARS(bytez)
#     binary2 = lief.parse(bytez2)
#     oldsections = [s.name for s in binary.sections]
#     newsections = [s.name for s in binary2.sections]
#     if len(newsections) == len(oldsections):
#         return 0
#     else:
#         return 1
#
#
# def test_imports_append2(bytez):
#     binary = lief.parse(bytez)
#     manip = MalwareManipulator(bytez)
#     bytez2 = manip.imports_append2(bytez)
#     binary2 = lief.parse(bytez2)
#     if len(binary.imported_functions) == len(binary2.imported_functions):
#         return 0
#     else:
#         return 1
#
#
# def test_section_rename(bytez):
#     binary = lief.parse(bytez)
#     # SUCCEEDS
#     manip = MalwareManipulator(bytez)
#     bytez2 = manip.section_rename(bytez)
#     binary2 = lief.parse(bytez2)
#     oldsections = [s.name for s in binary.sections]
#     newsections = [s.name for s in binary2.sections]
#     # print(oldsections)
#     # print(newsections)
#     if " ".join(newsections) == " ".join(oldsections):
#         return 0
#     else:
#         return 1
#
#
# def test_section_append(bytez):
#     binary = lief.parse(bytez)
#     # FAILS if there's insufficient room to add to the section
#     manip = MalwareManipulator(bytez)
#     bytez2 = manip.section_append(bytez)
#     binary2 = lief.parse(bytez2)
#     oldsections = [len(s.content) for s in binary.sections]
#     newsections = [len(s.content) for s in binary2.sections]
#     print(oldsections)
#     print(newsections)
#     if sum(newsections) == sum(oldsections):
#         return 0
#     else:
#         return 1
#
#
# def test_create_new_entry(bytez):
#     binary = lief.parse(bytez)
#     manip = MalwareManipulator(bytez)
#     bytez2 = manip.create_new_entry(bytez)
#     binary2 = lief.parse(bytez2)
#     # print(binary.entrypoint)
#     # print(binary2.entrypoint)
#     if binary.entrypoint == binary2.entrypoint:
#         return 0
#     else:
#         return 1
#
#
# if __name__ == '__main__':
#     bytez = interface.fetch_file("Exploit.Win32.ActivePost.g")
#     # print(test_ARBE(bytez))
#     # print(test_imports_append(bytez))
#     # print(test_random_imports_append(bytez))
#     # print(test_ARS(bytez))
#     # print(test_imports_append2(bytez))
#     # print(test_section_rename(bytez))
#     print(test_section_append(bytez))
#     # print(test_create_new_entry(bytez))
